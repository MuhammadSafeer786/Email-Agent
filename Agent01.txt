"""
LangGraph Email Reply Agent (single-file)
----------------------------------------
Features:
- Fetches unseen emails (IMAP) and full thread.
- RAG over previous emails + local files (./knowledge_base) with FAISS.
- Drafts a reply with LLM, self-critiques, revises in a loop, then sends reply (SMTP).
- All logic in one file; configurable via environment variables.

Quickstart
==========
1) pip install -U "langgraph>=0.2.22" langchain langchain-openai langchain-community faiss-cpu unstructured
2) Set env vars:
   - OPENAI_API_KEY
   - EMAIL_IMAP_HOST, EMAIL_IMAP_USER, EMAIL_IMAP_PASS
   - EMAIL_SMTP_HOST, EMAIL_SMTP_PORT (e.g. 587), EMAIL_SMTP_USER, EMAIL_SMTP_PASS
   - EMAIL_FROM_NAME (optional, defaults to IMAP/SMTP user)
   - DRY_RUN=true (to avoid sending while testing)
3) Create ./knowledge_base with .txt/.md/.eml files to ground the agent.
4) Run: python langgraph_email_agent.py

Note: Adjust loaders as needed for your email/file formats.
"""

from __future__ import annotations
import os
import asyncio
import re
import imaplib
import email
import smtplib
import ssl
from email.header import decode_header, make_header
from email.message import EmailMessage
from typing import List, Dict, Any, Optional, TypedDict

from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_community.vectorstores import FAISS

from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver
from dotenv import load_dotenv
load_dotenv()
# ----------------------------
# Config & Helpers
# ----------------------------
MODEL = os.getenv("OPENAI_MODEL", "gpt-4o-mini")
TEMPERATURE = float(os.getenv("MODEL_TEMPERATURE", "0.2"))
MAX_REWRITE_ITERS = int(os.getenv("MAX_REWRITE_ITERS", "2"))
CRITIQUE_THRESHOLD = float(os.getenv("CRITIQUE_THRESHOLD", "0.75"))
DRY_RUN = os.getenv("DRY_RUN", "true").lower() in {"1", "true", "yes"}

# Email config
IMAP_HOST = os.getenv("EMAIL_IMAP_HOST")
IMAP_USER = os.getenv("EMAIL_IMAP_USER")
IMAP_PASS = os.getenv("EMAIL_IMAP_PASS")
SMTP_HOST = os.getenv("EMAIL_SMTP_HOST")
SMTP_PORT = int(os.getenv("EMAIL_SMTP_PORT", "587"))
SMTP_USER = os.getenv("EMAIL_SMTP_USER", IMAP_USER)
SMTP_PASS = os.getenv("EMAIL_SMTP_PASS", IMAP_PASS)
FROM_NAME = os.getenv("EMAIL_FROM_NAME", SMTP_USER or IMAP_USER or "Agent")

KB_DIR = os.getenv("KB_DIR", "project_files")

# ----------------------------
# State
# ----------------------------
class AgentState(TypedDict):
    query: str  # subject + short summary of incoming email
    incoming_email: Dict[str, Any]  # {subject, from, to, body, message_id, thread}
    context_docs: List[str]
    draft: str
    critique: Dict[str, Any]
    final: str
    iters: int


# ----------------------------
# Email Tools
# ----------------------------
class IMAPEmailClient:
    def __init__(self, host: str, user: str, password: str):
        self.host = host
        self.user = user
        self.password = password

    def _connect(self):
        m = imaplib.IMAP4_SSL(self.host)
        m.login(self.user, self.password)
        return m

    def fetch_all_unseen(self, mailbox: str = "INBOX") -> List[Dict[str, Any]]:
        """Return ALL unseen emails with minimal fields."""
        m = self._connect()
        emails = []
        try:
            m.select(mailbox)
            typ, data = m.search(None, 'UNSEEN')
            if typ != 'OK' or not data or not data[0]:
                return []
            ids = data[0].split()

            for eid in ids:
                typ, msg_data = m.fetch(eid, '(RFC822)')
                if typ != 'OK':
                    continue
                raw = msg_data[0][1]
                msg = email.message_from_bytes(raw)

                emails.append({
                    "subject": str(make_header(decode_header(msg.get('Subject', '')))),
                    "from": str(make_header(decode_header(msg.get('From', '')))),
                    "to": str(make_header(decode_header(msg.get('To', '')))),
                    "message_id": msg.get('Message-ID', ''),
                    "body": self._get_body(msg),
                    "thread": self.fetch_thread(m, mailbox, msg),
                })
            return emails
        finally:
            try:
                m.close()
            except Exception:
                pass
            m.logout()



    def fetch_thread(self, connection, mailbox: str, msg) -> List[Dict[str, str]]:
        """Fetch simple thread by matching subject, ignoring Re:/Fwd: prefixes, safely."""
        # Normalize subject by removing "Re:" / "Fwd:" prefixes
        subj = msg.get('Subject', '')
        norm = re.sub(r'^(re:|fwd:|fw:)+\s*', '', subj, flags=re.I).strip()

        # Clean up subject to prevent IMAP parsing issues
        norm = norm.replace('"', '').replace('\\', '')

        connection.select(mailbox)

        # Prefer Message-ID search (more reliable than subject)
        message_id = msg.get('Message-ID', '').strip()
        if message_id:
            try:
                typ, data = connection.search(None, f'(HEADER Message-ID "{message_id}")')
                if typ == 'OK' and data and data[0]:
                    return self._build_thread_from_ids(connection, data[0].split())
            except Exception as e:
                print(f"[WARN] Message-ID search failed: {e}")

        # Fallback to subject search
        try:
            typ, data = connection.search(None, f'(HEADER Subject "{norm}")')
            if typ == 'OK' and data and data[0]:
                return self._build_thread_from_ids(connection, data[0].split())
        except Exception as e:
            print(f"[WARN] Subject search failed: {e}")

        return []

    def _build_thread_from_ids(self, connection, message_ids: list) -> List[Dict[str, str]]:
        """Helper to fetch emails for given message IDs."""
        out: List[Dict[str, str]] = []
        for mid in message_ids:
            typ2, msg_data = connection.fetch(mid, '(RFC822)')
            if typ2 == 'OK':
                raw = msg_data[0][1]
                m = email.message_from_bytes(raw)
                subject = str(make_header(decode_header(m.get('Subject', ''))))
                sender = str(make_header(decode_header(m.get('From', ''))))
                body = self._get_body(m)
                out.append({
                    "subject": subject,
                    "from": sender,
                    "body": body
                })
        return out


    @staticmethod
    def _get_body(msg) -> str:
        if msg.is_multipart():
            for part in msg.walk():
                ctype = part.get_content_type()
                disp = part.get('Content-Disposition')
                if ctype == 'text/plain' and disp is None:
                    try:
                        return part.get_payload(decode=True).decode(part.get_content_charset() or 'utf-8', errors='ignore')
                    except Exception:
                        continue
        else:
            if msg.get_content_type() == 'text/plain':
                return msg.get_payload(decode=True).decode(msg.get_content_charset() or 'utf-8', errors='ignore')
        return ""


def send_email_smtp(to_addr: str, subject: str, body: str, in_reply_to: Optional[str] = None):
    if DRY_RUN:
        print("[DRY_RUN] Would send email to:", to_addr)
        print("Subject:", subject)
        print("Body:\n", body)
        return

    msg = EmailMessage()
    msg["From"] = FROM_NAME
    msg["To"] = to_addr
    msg["Subject"] = subject
    if in_reply_to:
        msg["In-Reply-To"] = in_reply_to
        msg["References"] = in_reply_to
    msg.set_content(body)

    ctx = ssl.create_default_context()
    with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as server:
        server.starttls(context=ctx)
        server.login(SMTP_USER, SMTP_PASS)
        server.send_message(msg)


# ----------------------------
# RAG Index
# ----------------------------
class RAGIndex:
    def __init__(self, kb_dir: str):
        self.kb_dir = kb_dir
        self.embeddings = OpenAIEmbeddings()
        self.vs = None
        self.splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=150)

    def build(self):
        docs: List[str] = []
        if os.path.isdir(self.kb_dir):
            for root, _, files in os.walk(self.kb_dir):
                for fn in files:
                    if fn.lower().endswith((".txt", ".md", ".eml")):
                        path = os.path.join(root, fn)
                        try:
                            with open(path, "r", encoding="utf-8", errors="ignore") as f:
                                raw = f.read()
                                for chunk in self.splitter.split_text(raw):
                                    docs.append(chunk)
                        except Exception as e:
                            print(f"[KB] Skip {path}: {e}")
        if not docs:
            # Minimal bootstrap to avoid empty index
            docs = [
                "This knowledge base is currently empty. If needed, respond politely and ask for missing details."
            ]
        # store as FAISS vectorstore using documents as metadatas
        metadatas = [{"source": f"kb:{i}"} for i in range(len(docs))]
        self.vs = FAISS.from_texts(docs, self.embeddings, metadatas=metadatas)

    def search(self, query: str, k: int = 6) -> List[str]:
        if not self.vs:
            self.build()
        results = self.vs.similarity_search(query, k=k)
        return [r.page_content for r in results]


# ----------------------------
# LLMs
# ----------------------------
llm = ChatOpenAI(model=MODEL, temperature=TEMPERATURE)
critic_llm = ChatOpenAI(model=os.getenv("CRITIC_MODEL", MODEL), temperature=0.0)

SYSTEM_PROMPT = (
    "You are an email assistant for a busy professional.\n"
    "Write concise, polite, and helpful replies.\n"
    "Preserve necessary technical detail. Use bullet points when useful.\n"
    "NEVER invent facts; if context is missing, ask a short clarifying question.\n"
)

CRITIQUE_SYSTEM = (
    "You are a strict email reviewer.\n"
    "Score the draft from 0 to 1 on correctness, clarity, tone, and completeness.\n"
    "Return JSON: {\"score\": float, \"issues\": [..], \"must_fix\": [..], \"suggestions\": [..]}\n"
)

REWRITE_SYSTEM = (
    "You are revising an email draft.\n"
    "Apply all MUST-FIX issues while keeping the author's style professional and concise.\n"
)

# ----------------------------
# Graph Nodes
# ----------------------------
def read_unseen_node(state: AgentState, *, email_client: IMAPEmailClient) -> AgentState:
    msg = state.get("incoming_email")  # Use the email passed when spawning this graph
    if not msg:
        raise RuntimeError("No email provided to process.")

    query = (
        f"Subject: {msg['subject']}\n"
        f"From: {msg['from']}\n"
        f"Body Preview: {msg['body'][:500]}"
    )
    return {**state, "query": query}



def retrieve_context_node(state: AgentState, *, rag: RAGIndex) -> AgentState:
    inc = state["incoming_email"]
    # Build a query mixing subject, body, and last two thread messages
    thread_snips = "\n\n".join([t.get("body", "")[:800] for t in inc.get("thread", [])[-2:]])
    q = f"{inc['subject']}\n{inc['body']}\n{thread_snips}"
    ctx_docs = rag.search(q, k=6)
    return {**state, "context_docs": ctx_docs}


def draft_reply_node(state: AgentState) -> AgentState:
    inc = state["incoming_email"]
    ctx = state.get("context_docs", [])
    content = (
        f"{SYSTEM_PROMPT}\n\n"  # system content will be included via 'system' message but
        # we keep here for single-file clarity if you adapt to raw API
    )
    user_msg = (
        "Compose a reply email to the following message.\n\n"
        f"Incoming Email:\nSubject: {inc['subject']}\nFrom: {inc['from']}\nBody:\n{inc['body']}\n\n"
        f"Relevant Context (RAG):\n- " + "\n- ".join(ctx)
    )
    resp = llm.invoke([
        {"role": "system", "content": SYSTEM_PROMPT},
        {"role": "user", "content": user_msg},
    ])
    draft = resp.content.strip()
    return {**state, "draft": draft, "iters": state.get("iters", 0)}


def critique_node(state: AgentState) -> AgentState:
    inc = state["incoming_email"]
    draft = state["draft"]
    user_msg = (
        "Review the draft reply for this incoming email.\n\n"
        f"Incoming Subject: {inc['subject']}\nIncoming From: {inc['from']}\nIncoming Body:\n{inc['body']}\n\n"
        f"Draft Reply:\n{draft}\n\n"
        "Return only the requested JSON."
    )
    resp = critic_llm.invoke([
        {"role": "system", "content": CRITIQUE_SYSTEM},
        {"role": "user", "content": user_msg},
    ])
    # Best-effort JSON parse
    import json
    txt = resp.content.strip()
    try:
        data = json.loads(txt)
    except Exception:
        # try to extract JSON with a regex fallback
        m = re.search(r"\{[\s\S]*\}", txt)
        data = json.loads(m.group(0)) if m else {"score": 0.0, "issues": ["Malformed critique"], "must_fix": [], "suggestions": []}
    return {**state, "critique": data}


def will_revise(state: AgentState) -> str:
    iters = state.get("iters", 0)
    score = float(state.get("critique", {}).get("score", 0.0))
    if score >= CRITIQUE_THRESHOLD or iters >= MAX_REWRITE_ITERS:
        return "approve"
    return "revise"


def revise_node(state: AgentState) -> AgentState:
    draft = state["draft"]
    critique = state["critique"]
    must_fix = "\n- ".join(critique.get("must_fix", []))
    suggestions = "\n- ".join(critique.get("suggestions", []))
    user_msg = (
        "Revise the draft email. Apply MUST-FIX items. Consider suggestions if helpful.\n\n"
        f"Draft:\n{draft}\n\n"
        f"MUST-FIX:\n- {must_fix}\n\n"
        f"Suggestions:\n- {suggestions}\n"
    )
    resp = llm.invoke([
        {"role": "system", "content": REWRITE_SYSTEM},
        {"role": "user", "content": user_msg},
    ])
    new_draft = resp.content.strip()
    return {**state, "draft": new_draft, "iters": state.get("iters", 0) + 1}


def finalize_node(state: AgentState) -> AgentState:
    return {**state, "final": state["draft"]}


def send_node(state: AgentState) -> AgentState:
    inc = state["incoming_email"]
    final = state["final"]
    subj = f"Re: {inc['subject']}"
    # Extract a simple reply-to address from the From header
    to_addr = re.search(r"<([^>]+)>", inc["from"]) or re.search(r"([^\s@<>]+@[^\s@<>]+)", inc["from"]) 
    to_email = to_addr.group(1) if to_addr else inc["from"]
    send_email_smtp(to_email, subj, final, in_reply_to=inc.get("message_id"))
    return state


# ----------------------------
# Build Graph
# ----------------------------
def build_graph(email_client: IMAPEmailClient, rag: RAGIndex):
    graph = StateGraph(AgentState)
    graph.add_node("read_unseen", lambda s: read_unseen_node(s, email_client=email_client))
    graph.add_node("retrieve_context", lambda s: retrieve_context_node(s, rag=rag))
    graph.add_node("draft", draft_reply_node)
    graph.add_node("critique", critique_node)
    graph.add_node("revise", revise_node)
    graph.add_node("finalize", finalize_node)
    graph.add_node("send", send_node)

    graph.set_entry_point("read_unseen")
    graph.add_edge("read_unseen", "retrieve_context")
    graph.add_edge("retrieve_context", "draft")
    graph.add_edge("draft", "critique")
    graph.add_conditional_edges("critique", will_revise, {"revise": "revise", "approve": "finalize"})
    graph.add_edge("revise", "critique")  # loop until threshold / max iters
    graph.add_edge("finalize", "send")
    graph.add_edge("send", END)

    memory = MemorySaver()
    return graph.compile(checkpointer=memory)


async def run_email_graph(email_client: IMAPEmailClient, rag: RAGIndex, email_data: dict):
    try:
        app = build_graph(email_client, rag)

        # initial state includes the current email
        state: AgentState = {
            "incoming_email": email_data,
            "query": "",
            "context_docs": [],
            "draft": "",
            "critique": {},
            "final": "",
            "iters": 0,
        }

        # run the graph
        async for update in app.astream(state, config={"configurable": {"thread_id": email_data["message_id"]}}):
            for k, v in update.items():
                print(f"[NODE] {k} â†’ {v}")

        print(f"[DONE] Finished processing email: {email_data['subject']}")

    except Exception as e:
        print(f"[ERROR] {email_data['subject']}: {e}")


async def main():
    email_client = IMAPEmailClient(IMAP_HOST, IMAP_USER, IMAP_PASS)
    rag = RAGIndex(KB_DIR)
    rag.build()
    print(dir(email_client))

    while True:
        unseen_emails = email_client.fetch_all_unseen(mailbox="INBOX")
        if unseen_emails:
            print(f"[INFO] Found {len(unseen_emails)} new email(s). Spawning tasks...")

        for email_data in unseen_emails:
            print(f"[START] Processing email from: {email_data['from']} - {email_data['subject']}")
            asyncio.create_task(run_email_graph(email_client, rag, email_data))

        await asyncio.sleep(10)  # poll every 10 seconds


if __name__ == "__main__":
    asyncio.run(main())